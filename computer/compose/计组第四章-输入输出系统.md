---
title: 第四章 IO
category: 计算机组成原理
order: 4
excerpt: 计组第四章-IO
---

## 概述
### I/O系统的发展概述
1. 早期
    - 分散连接
    - CPU和I/O设备**串行**工作 程序查询方式(CPU必须运行某个程序查询I/O的输入和输出)
2. 接口模块和DMA阶段
    - 总线连接
    - CPU和I/O设备**并行**工作
        - 中断方式
        - DMA方式
3. 具有通道结构的阶段(通道相当于一个微处理器)
4. 具有I/O处理机的阶段
### I/O的组成
1. I/O软件
    - I/O指令(CPU指令的一部分)
    ![I/O指令](/compose/42.png)
    - 通道指令(通道自身的指令)
2. I/O硬件
    - 设备 I/O接口
    - 设备 设备控制器 通道
### I/O设备与主机的联系方式
1. I/O设备编址方式
    - 统一编址

        将内存和I/O设备一起编址 比如将高位给内存低位给I/O

        可以用取数、存数指令对内存和I/O进行操作
    - 不统一编址

        需要用专门的I/O指令对I/O设备操作
2. 设备选址

    用**设备选择电路**识别是否被选中(CPU给出的地址和设备自己保存的地址比较)
3. 传送方式
    - 串行
    - 并行
4. 联络方式
    - 立即响应(LED)
    - 异步工作采用应答信号
    ![异步](/compose/43.png)
    - 同步工作采用同步时标
5. I/O设备与主机的连接方式
    - 辐射式连接(分散连接 每连接一个I/O就要由一条控制线和信号线)
    - 总线连接
### I/O设备与主机信息传送的控制方式
1. 程序查询方式
```mermaid
    flowchart TB
        A[CPU向I/O发读指令]-->B[CPU读I/O状态]-->C{检查状态}
        C-->已准备就绪-->E[从I/O接口中读一个字到CPU]-->F[从CPU向主存写入一个字]-->G{完成否}--是-->H[下面的程序]
        C-->D[出错程序]
        C--未准备就绪-->B
        G--否-->A
```
2. 程序中断方式
    ![中断](/compose/43.png)
    :::info 栗子
    CPU正在执行我写的辣鸡程序
    ```python
        def callback(file):
            print(file)
        if __name__ == '__main__':
            print('开始了')
            ReadFile('USB1',callback)
            print('1')
            print('2')
            print('3')
    ```
    CPU先执行第一条print('开始了')向终端输出开始了

    然后执行ReadFile这个函数(CPU叫USB1启动然后准备数据)

    然后执行print('1')

    这个时候USB1准备好了数据CPU不执行print('2')了

    执行callback这个函数 并且将USB1的数据传进去执行print(file)

    执行完callback后再回来执行print('2')print('3')

    ::: 
3. DMA方式
    1. CPU执行一个I/O指令启动I/O设备(之后执行自己后面程序I/O不管了)
    2. DMA控制器控制I/O设备准备数据
    3. 准备好后DMA控制器发送一个请求占用总线(只需要一个存取周期 此时CPU不能访问主存)
    4. I/O和主存完成数据交换(这时CPU可以执行自己的程序)
    5. 完成存取

4. 比较

![比较](/compose/45.png)


## I/O设备
1. 人机交互设备(键盘、鼠标、显示器等)
2. 计算机信息存储设备(磁盘、光盘等)
3. 机-机通信设备(调制解调器等)

## I/O接口
### 概述
**为什么要设置接口**
1. 实现设备的选择
2. 实现数据缓冲达到速度匹配(主机与I/O接口速度不匹配)
3. 实现数据串-并格式转换(可能主机到I/O是并行 I/O只能串行)
4. 实现电平转换(主机和I/O的工作电压不一致)
5. 传送控制命令
6. 反应设备的状态
### 接口的功能和组成
1. 总线连接方式的I/O接口电路
![img](/compose/46.png)
2. 接口的功能和组成
![img](/compose/47.png)
3. I/O接口的基本组成
![img](/compose/48.png)
## 程序查询方式
==程序流程==

![img](/compose/49.png)

==程序查询方式的接口电路==

![img](/compose/50.png)
::: info 将I/O设备的数据输入到主机(输入到主存的某个单元)
1. 主机给出地址线 设备选择电路将地址线和自己的端口号比对 有效则使SEL有效
2. 启动命令和SEL同时有效才启动设备
3. B有效 启动设备 设备准备数据
4. 设备准备好数据让4线置1(给主机发信号说已准备就绪) 数据传入到DBR寄存器
:::
## 程序中断方式
### 中断的概念
CPU在运行过程中若发生紧急事件 则停止当前任务 去完成紧急事件 当紧急事件完成再来完成当前任务
### I/O中断的产生
![img](/compose/51.png)
### 程序中断方式的接口电路
#### 配置中断请求触发器和中断屏蔽触发器 
![img](/compose/52.png)
::: info
1. 当I/O设备的数据准备好时 D完成触发器置1 
2. 当D置1和中断屏蔽触发器输出端Q非置1(没有被屏蔽)时INTR一端置1
3. CPU的中断查询信号输入INTR另一端
4. 发出中断请求
:::
#### 排队器
- 软件：[第八章](/computer/compose/)
- 硬件

![img](/compose/53.png)
::: info 
假设INTR2和INTR3发出中断请求
![img](/compose/54.png)
1. 除了INTR1和INTR2 后面所有的向上输出都是0
![img](/compose/55.png)
2. 这样就能找到INTP2
:::
#### 中断向量地址形成部件(找到中断服务程序入口地址)
- 软件：[第八章](/computer/compose/)
- 硬件

    由硬件产生向量地址 再由向量地址找到入口地址

    ![img](/compose/56.png =x300)
    ![img](/compose/57.png =x300)
    ::: details UnderStand
    假设一共由256个中断源 CPU自启动开始就无时无刻不在处理中断 所以得把中断服务程序放在内存一块固定的位置(称作中断向量表)(方便CPU寻找中断服务程序)

    在CPU启动时 取内存一块地方放中断向量表 所有每一个中断向量都由段地址(中断向量表的首地址)+偏移地址(向量相对于首地址的位置)

    :chestnut:

    假设中断向量表的地址是0101011  每一个向量(每一个中断源)占5位

    第一个中断源的地址就是010101+0=010101

    第二个中断源的地址是010101+5=011010 以此类推

    ---
    ---
    ---

    但是中断服务程序可能特别特别大也可能特别特别小 我们不能固定一块相同大小的内存存储程序(中断服务程序)

    所以我们在中断向量表里不存储程序 存储程序所在的地址

    :chestnut:

    假设第二个中断源发出了中断请求 CPU要执行第二个中断源的中断服务程序

    于是CPU先找到获得第二个中断源的中断向量 假设是10101+5=011010

    CPU到内存的011010这个地址上去看  因为中断向量表存储的是入口地址 于是CPU看到了1010111这个地址 于是CPU去1010111这个地址找到了程序 开始执行
    :::

#### 程序中断方式接口电路的基本组成
![中断接口电路](/compose/58.png)

### I/O中断处理过程
![img](/compose/59.png)
### 中断服务程序流程
1. 保护现场
    - 程序断点的保护
    - 寄存器内容的保护 进栈
2. 中断服务

    对不同的I/O设备具有不同内容的设备服务
3. 恢复现场 出栈
4. 中断返回
## DMA方式