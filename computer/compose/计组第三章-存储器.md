---
title: 第三章 存储器
category: 计算机组成原理
order: 3
excerpt: 计组第三章-总线
---
## 概述

### 存储器分类

- 按存储介质分类
  - 半导体存储器   TTL、MOS
  - 磁表面存储器   磁头、载磁体
  - 磁芯存储器     硬磁材料、环状元件
  - 光盘存储器    激光、激光材料

- 按存取方式分类
  - 存取时间与物理地址无关(随机访问)
    - 随机存储器	在程序的执行过程中可读可写
    - 只读存储器    只读
  - 存取时间与物理地址有关(串行访问)
    - 顺序存取存储器  磁盘
    - 直接存取存储器  磁盘

- 按在计算机中的作用
  - 主存储器
    - RAM(可读可写)
      - 静态RAM
      - 动态RAM
    - ROM(只读)
      - MROM
      - PROM
      - EPROM
      - EEPROM
  - 辅助存储器     磁盘、磁带、光盘
  - Cache(作为cpu和主存的缓冲)
  - Flash Memory(作为主存和辅助存储器的缓冲)

### 存储器的层级结构

#### 存储器三个主要特征的关系

![image-20230317092253961](/imgs/image-20230317092253961.png)

#### 缓存-主存层次和主存-辅存层次

![image-20230317092832311](/imgs/image-20230317092832311.png)

![image](/imgs/image-20230317093205018.png)


## 主存储器

### 概述

#### 主存的基本组成

![image-20230317093508777](/imgs/image-20230317093508777.png)

#### 主存和CPU的联系

![image-20230317093557218](/imgs/image-20230317093557218.png)

#### 主存中存储单元地址的分配

![image-20230317094658587](/imgs/image-20230317094658587.png)

> 前提是字长32位  按字节寻址  每一个字节拥有一个地址   有两种方式 一个是高位字节的地址作为字的地址  就是大端、大尾  字节地址就是高位字节的地址  把高位字节的地址当作字地址  小尾则反过来 把低位字节的地址当作字的地址

![image-20230317095003451](/imgs/image-20230317095003451.png)

> 如果地址线是24根  按字节寻址  一共可以编址16MB 也就是000000表示第一个字的第一个字节 11111表示最后一个字的最后一共字节
>
> 若字长为16位  按字寻址  一共可以编址2^23^位地址也就是8MW(Word)一个字16位2个字节还需要留一位给字节  也就是 00000 1表示第一个字的第二个字节 1111 0表示最后一个字的第一个字节
>
> 若字长位32位则需要拿出2位来给字节编址也就是4MW

#### 主存的技术指标

- 存储容量
- 存储速度
  - 存取时间   存储器的访问时间
    - 读出时间  写入时间
  - 存取周期    连续两次独立的存储器操作(读或写)所需的最小间隔时间
- 存储器的带宽  位/秒

### 半导体存储芯片简介

#### 基本结构

 ![image-20230317101355279](/imgs/image-20230317101355279.png)



![image-20230317101712619](/imgs/image-20230317101712619.png)

> 片选线 规定当前存储芯片是否被选中

![image-20230317102059527](/imgs/image-20230317102059527.png)

> 16K x 1位 地址线是16K  MAR是2^14^次方  MDR是1位 也就是 一个有16K的字  一个字是1位
>
> 如果将8片组在一起看成一个整体就是16K x 8 对这8片芯片的读写是一起的 把这8片的片选线连在一起 。当片选线为低 地址线为14位0 也就是第一个字  读出来8位
>
> 用4组这样的8片在一起  组成64K  0-(16k-1)表示第一个8片 16K-(32K-1)表示第二个8片 32K-(48K-1)表示第三片  48K-(64K-1)表示第4片
>
> 当CPU给出的地址是65535时 属于第4片的地址 于是将其余3片片选设为高电平 第四片片选设为低电平  然后65535也就是第4片的最后一个字 将第四片的8个芯片的每一个的最后一个字取出

#### 半导体存储芯片的译码驱动方式

##### 线选法

![image-20230317103857876](/imgs/image-20230317103857876.png)

> 每一行的个芯片的片选线是连在一起的
>
> 将每一行的片选线接到地址译码器上 当输入0000 译码之后是0 第一行片选线设为低电平 其余设为高电平  读/写控制电路从第一行读/写

==缺点==  如果地址线是20条 那么译码出来是1M条线 线束太多会非常密集

##### 重合法

![image-20230317104825841](/imgs/image-20230317104825841.png)

>线选法是将8个芯片在一行 重合法将8个芯片看作一个坐标(0,0)(0,1)每一个坐标表示8个芯片假设一个芯片的MAR是1位 (0,1)输出8位
>
>假设地址线是10根 如果是线选法 译码出来是1K条线  如果分成XY两条 则译码出来是64根 大大减少线束
>
>寻找方法: 假设地位(x)地址是0001 高位(y)地址是00000  就会选出坐标为(1,0)的8个芯片



### 随机存取存储器(RAM)
#### 静态RAM(SRAM)
- [ ] 保存0和1的原理是什么？
- [ ] 基本单元电路的构成是什么?
- [ ] 对单元电路如何读出和写入?
- [ ] 典型芯片的结构是什么样子?
- [ ] 静态RAM芯片是如何进行读和写的？

---
---

- [x] 保存0和1的原理是什么？

![RS触发器](/compose/2.png)
::: tip 复习
复习一下触发器叭
1. 通常Q端的逻辑电平当作触发器的状态
2. S端位置位端 R端位复位端
3. CLK为1时 当S端位1 R端为0 Q端为1 当S端为1 R端为0 Q端为0
4. CLK为1时 当S和R端都为0 Q端保持上一次状态
5. CLK为1时 当S和R端都为1 Q端和~Q端都为1 为禁止状态
6. CLK为0时 Q端都保持原来的状态

当S和R端都为0 不管触发器原来的状态是0态还是1态，触发器的状态都不变，说明触发器具有保持的特性，能够记忆历史的状态。
:::
---
---

- [x] **基本单元电路的构成是什么?**
::: center
==核心利用触发器构成==
:::

::: info 大致理解
==静态RAM基本电路==
![静态RAM基本电路](/compose/1.png)
A端和A'端为触发器的Q端和Q'端

当地址选择没有选中这个单元 A端和A'端保持原来的状态不变 相当于CLK为0

当地址选择选中这个单元 A端和A'端输出保存的信息 相当于CLK为1

==SRAM的基本单元==
![SRAM的基本单元](/compose/5.png)
当WL为低电平时 MAL和MAR没有导通 里面两个二极管形成回路 若是状态1则高电平会在回路打转保存下去 若是状态0则没有电流

读操作:将WL置1 读操作置1 MAL和MAR导通 里面的电流会流向bit和bit'两者互反

写操作:将WL置1 写操作置1 bit中的信息流向里面的回路
:::

---
---
- [x] **对单元电路如何读出和写入?**

::: info 读操作
![SRAM的读操作](/compose/3.png)
**将行选和列选打开  也就是相当于把触发器的CLK线置为1**
![SRAM的读操作](/compose/4.png)
**触发器中的数据会从A端通过位线A到D~out~在到IO或者CPU**
:::

::: tip 写操作
![SRAM的写操作](/compose/6.png)

行选和列选都打开 写选择置1 bit'经过或门和bit互反写入T~1~到T~4~
:::
---
---
- [x] **典型芯片的结构是什么样子?**

**1. Intel 2114 外特性**

![Intel 2114 引脚图](/compose/7.png)
::: note 
- WE为读/写命令(低为读 高为写)
- CS为片选线 低表示该芯片被选中
- I/O 1-4表示每次输入输出4位
- 10条地址线表示一共有1k个基本单元(2^10^=1024)
- 存储容量为 1K X 4位=4096
::: 

==SRAM的基本单元是只能存储一位 重合法只能选中一列一行 怎么实现重合法选中4列呢==

**2. Intel 2144 RAM矩阵(64X64=4096) 读/写**

![Intel 2114](/compose/8.png)
::: info 理解
一共10条数据线

- 6条给行地址译码 2^6^=64 对应64行

- 4条给列地址译码 2^4^=16 64列 每16列一组一共4组

当列地址为0001时 选中第2条列 也就是第一组的第二列 第二组的第二列 第三组的第二列 第四组的第二列 一共4列 加上行选择器选中的一行 正好输出4个单元

:::
::: center
==**举个栗子**==
:::
![Intel 2114](/compose/9.png)
::: note
行地址为000000 列地址为0000

选中第一行和每一组的第一列 就是橘黄色的那4个拉
:::

#### 动态RAM(DRAM)
- [ ] 保存0和1的原理是什么？
- [ ] 基本单元电路的构成是什么?
- [ ] 对单元电路如何读出和写入?
- [ ] 典型芯片的结构是什么样子?
- [ ] 动态RAM芯片是如何进行读和写的？
- [ ] 动态RAM为什么要刷新，刷新方法?

***
***

- [x] 保存0和1的原理是什么？

通过电容充放电来保存0和1

---
---
- [x] 基本单元电路的构成是什么?

**基本单元**

![DRAM基本单元](/compose/10.png)

读(WL为高电平)
- 若电容已充电(为状态1) 电容放电 bit为1
- 若电容没电(为状态0) 电容不放电 bit为0

写(WL为高电平)

- 若bit为高电平 给电容充电
- 若bit为低电平 电容有电则放电 无电则不变

**基本单元电路**

![DRAM基本电路](/compose/11.png)

**读(读选择线置1) T~2~打开**

预充电信号置1 T~4~打开 V~DD~给读数据线充电(读数据线为1) 
- 若电容有电(状态1) 则放电 T~1~导通 读数据线接地 放完电变0
- 若电容没电(状态0) 电容不放电 读数据线为1

**读出原存信息相反**

---

**写(写选择线置1) T~3~打开**
- 若写数据为高电平 给电容充电
- 若写数据为低电平 电容有电则放电 无电则不变

**写入与输入信息相同**

---
---

- [x] 典型芯片的结构是什么样子?
  - 三管动态RAM芯片(Intel 1103)
![Intel 1103](/compose/12.png)
::: info 
  读写操作和SRAM基本相同 读写选择线嵌入地址译码器中
  每过一段时间要刷新一遍
:::

---
---
- [x] 动态RAM为什么要刷新，刷新方法?
1. 原因

    时间长电容里的电会慢慢漏掉

2. 刷新方法
    - **刷新与行地址有关**
    
      给出行地址 那一行的信息会送到读数据线 若在读和写之间放个刷新器 我们就可以对这个一整行进行刷新 所以刷新只跟行地址有关
    - **假设存取周期0.5us 刷新周期为2ms 128X128的矩阵**
    
      在2ms内 所有的存储单元都要进行一次刷新 
    - **集中刷新**

      ![集中刷新](/compose/13.png)

      2ms内专取128个周期用来刷新 刷新过程中不能读/写 称为**死区**
    
    - **分散刷新(存取周期为1us)**

      ![分散刷新](/compose/14.png)

      在每一次存取周期后花一个周期来刷新 但是总的来看存取周期就变成了1us W/R花0.5us REF花0.5us 只需要128个存取周期就可以刷新一遍
      ::: warning
        第一个周期读了第二行花0.5us 下一个0.5us给第一行刷新

        第二个周期读了第五行 下一个0.5us给第二行刷新

        如此只需花128个周期就可以给整个刷新

        但是没必要 因为刷新频率过快会消耗很多资源
        电容也不需要刷新那么快
      :::
    - **分散刷新与集中刷新相结合(异步刷新)**

      ![异步刷新](/compose/15.png)

      刷新周期为2ms 我们将2ms分成128份 15.6us

      我们每15.6us刷新一行
      
      我们可以在2ms内刷新完128行


      如果把刷新的0.5us放在译码阶段 也可以保证无死区


#### 动态RAM和静态RAM的比较
![DRAM与SRAM比较](/compose/16.png)


### 只读存储器(ROM)
- 早期的只读存储器--厂家早就写好了内容
- 改进1--用户可以自己写--一次性写进
- 改进2--可以多次写--要能对信息进行擦除--擦除设备需额外购买
- 改进3--电可擦写--需要特定设备
- 改进4--电可擦写--直接连接到计算机
#### 掩模ROM(MROM)
![1Kx1的掩模ROM结构](/compose/17.png)

::: info
0和1的区别是相应存储单元有无MOS管

每一根输出数据线都是高电平 当有MOS管的行选择被选中 对应MOS管打开 数据线接地变成低电平 没有MOS管的则输出高电平

无法更改MOS管的有无 所以里面的数据无法修改

举个栗子  

行地址00000 列地址00000 输出应该是(0,0)这个存储单元的数据 因为它有MOS管 当被选中时 其MOS管打开 数据线接地变成低电平 于是输出0

行地址00000 列地址00003 输出是(0,3)这个存储单元存储的数据 由于它没有MOS管 数据线是高电平 于是输出1

:::
#### PROM(一次性编程)
![PROM基本单元](/compose/18.png)

::: note
厂家出厂时 熔丝未断开

当编程时 给一个高电流让熔丝断开设为0 不给高电流熔丝不断开设为1

当读取时 若不导通则是0 导通则是1

由于熔丝不可恢复 所以是一次性编程
:::
#### EPROM(多次性编程)
![N型沟道浮动栅MOS电路](/compose/19.png)

**编程**
  - 给D端加正电压 形成浮动栅 导致S与D不导通 设为0
  - D端不加电压  不形成浮动栅 S与D可以导通 设为1
  - 用紫外线驱散浮动栅可以实现多次编程
#### EEPROM(电可擦)
- 电可擦写
- 局部擦写
- 全部擦写
#### Flash Memory(闪速型存储器)
具备RAM一些功能
### 存储器与CPU的连接
#### 存储器容量的拓展
**位拓展**(增加存储字长)

用2片1Kx4的存储芯片组成1Kx8的存储器

![位拓展](/compose/20.png)

::: info understand
将地址线同时输入2片芯片
将每片的数据分别输出到4根数据线 一共8位
:::
**字拓展**

用2片1Kx4的存储芯片组成2Kx4的存储器

![字拓展](/compose/21.png)

::: info understand
加1根A~10~地址线连接芯片的片选线 0选中第一个芯片 1则选中第二个芯片 这样就可以从逻辑上实现1Kx8到2Kx8
:::
**同时拓展**

用8片1Kx4的存储芯片组成4Kx8的存储器(需要12根地址线)

![同时拓展](/compose/22.png)
#### 存储器与CPU的连接
- 地址线的连接
- 数据线的连接
- 读/写命令线的连接
- 片选线的连接
- 合理选择存储芯片
- 时序、负载
### 存储器的校验
**编码的检测能力和纠错能力和什么有关**

任意两组合法代码之间==二进制位==的==最少差异数==

**1. 编码的最小距离**

  任意两组合合法代码之间==二进制位数==的==最小差异==

  ==编码的纠错、检错能力与编码的最小距离有关==

  $$
  L-1=D+C(D \geq C)\\
  L -- \text{编码的最小距离}\\
  D -- \text{检测错误的位数}\\
  C -- \text{纠正错误的位数}
  $$
**2. 汉明码的组成**
  - 汉明码采用奇偶校验
  - 汉明码采用分组校验
  ::: details 理解
  ![分组校验(无交叉)](/compose/23.png)

  - 汉明码的分组是一种非划分方式(分组的划分有交叉)
  ![分组校验(有交叉)](/compose/24.png =300x)

  分成3组，每组有一位校验位，共4位数据位

  ![分组校验(有交叉)](/compose/25.png)

  **编码**
  
  第一组 xxxx1 第二组 xxx1x 第三组 xxx1xx

  某个数字的二进制只要包含xxxx1就是第一组

  比如 3: 011 既属于第一组也属于第二组

  像00001 只属于第一组的我们把它当作第一组的校验位
  00010 只属于第二组我们把它当作第二组的校验位

  ---
  举个栗子 [1,2,3,4,5,6,7] 
  
  1,3,5,7属于第一组

  2,3,6,7属于第二组

  4,5,6,7属于第三组

  1，2，4位放我们的校验位

  **校验**

  在传输后我们把校验位取出 假设校验之后的结果是

  000 无差错 001 表示第一位出错 101表示第5位出错

  :::
  - 组成汉明码的三要素
    - 需要增添几位检测位

      $2^{k} \geq n+k+1$
    - 检测位的位置

      $2^{i}(i=0,1,2,3,\cdots)$
    - 检测位的取值

      和采用奇校验还是偶校验有关
  - 求==0101==按"偶校验"配置的汉明码
    ::: details 解
      $$
      \begin{aligned}
       \because\quad&n=4\\
          &\text{根据}2^{k} \geq n+k+1\\
          &\text{得}k=3
      \end{aligned}
      $$
      采用偶校验

      第一组是1，3，5，7  C~1~ = 0
      
      第二组是2，3，6，7 C~2~ = 1

      第三组是4，5，6，7 C~4~ = 0

      ![汉明码例子](/compose/26.png)
      
      $\therefore\quad 0101\text{的汉明码为} 0100101$
    :::
  - 汉明码的纠错过程
    ::: details 过程(上面例子的接收方)
      按相同的方式进行分组 生成检测位P~4~P~2~P~1~

      ![P取值](/compose/27.png)

      不出错时 P~1~=0，P~2~=0，P~4~=0

      假设 P~1~P~2~P~4~=011 说明是第2组和第3组都有的出错 也可以通过011的10进制6  第6位出错

    :::
### 提高访存速度的措施
  - 采用高速器件
  - 采用层次结构Cache-主存
  - 调整主存结构

    **1. 单体多字系统**

      ![img](/compose/28.png)
      ::: details 信息 
        机器字长16位 存储字长64位 

        增加一个单字长(机器字长)寄存器

        每次存/取数据都存/取64位出来 给cpu时一次一次给单字长寄存器 由单字长寄存器给cpu

        缺点:

          1. 当只需要存16位时 但是存储器只能存64位 会导致其他地方的数据出错
          2. 当取出第一个16位指令是跳转时 其他3条指令就没意义了


      :::
    **2. 多体并行系统**

        1. 高位交叉
      ![img](/compose/30.png)
      > 在执行程序时 由于程序都在相邻的存储空间内 会导致一块存储体一直工作 其他存储体空闲
      
        2. 低位交叉

      ![img](/compose/29.png)
      > 编址的时候将相邻存储地址放在不同的存储体 所以在执行程序时 所以的存储体都会用上

    **3. 高性能存储芯片**
      1. SDRAM(同步DRAM)
        在系统时钟的控制下进行读出和写入 CPU无需等待
      2. RDRAM
      3. 带Cache的DRAM
## 高速缓冲存储器(Cache)

### 概述
**1. 问题的提出**

  避免CPU“空等”现象 

  CPU和主存(DRAM)的速度差异

  ![img](/compose/31.png)
**2. Cache的工作原理**

  1. 主存和缓存的编址

  ![img](/compose/32.png)

  2. 命中与未命中

  ![img](/compose/33.png)

  3. Cache-主存系统的效率

  ![img](/compose/34.png)
**3. Cache的基本结构**

  ![img](/compose/35.png)

**4. Cache的读/写操作**

  ![img](/compose/36.png)

  ![img](/compose/37.png)

**5. Cache的改进**

  ![img](/compose/38.png)
### Cache-主存的地址映射
1. 直接映射

  ![img](/compose/39.png)

2. 全相联映射

  ![img](/compose/40.png)

3. 组相联映射

  ![img](/compose/41.png)
### 替换算法
  1. 先进先出(FIFO)算法
  2. 近期最少使用(LRU)算法


## 辅助存储器

