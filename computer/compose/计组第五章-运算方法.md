---
title: 第五章 运算方法
category: 计算机组成原理
order: 5
excerpt: 计组第五章-运算方法
---

## 无符号数和有符号数
### 无符号数
如果它保存在寄存器中 那么它的大小就是寄存器的位数  8位寄存器表示范围是0~255(8个0到8个1) 16位寄存器表示范围是0~65535(8个0到16个1)
### 有符号数

#### 机器数和真值

| 真值 | 机器数 |
| :-: | :-: |
| 带符号的数 | 符号数字化的数 |
| 符号在前 | 取第一位表示符号(1是- 0是+) |
| +101,-101 | 1,101,0,101 |

#### 原码表示法 
1. 定义

    **整数**
    $$[x]_{\text{原}}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        2^{n}-x\quad 0\geq x>-2^{n}
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1110  [x]~原~=0,1110

    x=-1110  [x]~原~=2^4^-(-1110)=1,1110

    **小数**
    $$[x]_{\text{原}}= \begin{cases}
        x\quad 1>x\geq 0 \\
        1-x\quad 0\geq x>-1
    \end{cases}
    $$
    x=+0.1101    [x]~原~=0.1101(前面0表示符号位)

    x=-0.1101    [x]~原~=1-(-0.1101)=1.1101

2. 特点
    - 简单
    - 直观
3. 缺点

    当需要进行加法运算时

    | 要求  数1 数2 | 实际操作  结果符号 |
    | :-: | :-: |
    | 加法  正  正 | 加 正|
    | 加法  正  负 | 减  可正可负 |
    | 加法  负  正 | 减  可正可负 |   
    | 加法  负  负 | 加  负 | 
    ::: info 
    能否找到一个与负数等价的正数来代替这个负数

    使得减法-->加法
    :::
#### 补码表示法
1. 补的概念
    ::: tip 时钟
    我们要把时间从6点调到3点

    逆时针  直接6-3=3

    顺时针  6+9=15-12=3

    可见-3可以用+9代替 也就是把减法-->加法

    因为时钟以12为模  每经历12小时(每到12点)就会变成0

    我们称+9是-3以12为模的补数  记作-3=+9(mod 12)
    :::
    **结论**
    - 一个负数加上**模**即可得到该负数的补数
    - 一个正数和一个负数互为补数时 它们绝对值之和即为**模**数

    **计算机的补数**
    - 4位寄存器(模16)
        ::: tip UnderStand
        如果想1011-->0000

        逆向    1011-1011=0000

        正向    1011+0101=10000(4位寄存器最高位忽略)=0000

        所以-1011=+0101(mod 2^4^)

        -0.1001=+1.0111(mod 2)
        :::
    - 正数的补数即为其本身
        ![img](/compose/72.png)
    - 对于机器码
    ::: info 对于机器码

    **正数**
    
    +0101 = 0,0101 其补码是本身 
    
    0,0101=0,0101(mod 2^4+1^)

    **负数**
    
    -0101=1,0101 其补码是100000-0101=1,1011  
    
    1,0101=1,1011(mod 2^4+1^)
    :::

2. 补码定义

    **整数**
    $$[x]_{\text{补}}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        2^{n+1}+x\quad 0\geq x>-2^{n}(mod 2^{n+1})
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1010  [x]~补~=0,1010

    x=-1011000  [x]~补~=2^7+1^+(-1011000)=1,0101000

    **小数**
    $$[x]_{\text{补}}= \begin{cases}
        x\quad 1>x\geq 0 \\
        2+x\quad 0\geq x>-1(mod 2)
    \end{cases}
    $$
    x=+0.1110    [x]~补~=0.1110(前面0表示符号位)

    x=-0.1100  [x]~补~=2+(-0.1100)=1.0100
#### 反码表示法
1. 定义

    **整数**
    $$[x]_{\text{反}}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        (2^{n+1}-1)+x\quad 0\geq x>-2^{n}(mod 2^{n+1}-1)
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1010  [x]~反~=0,1010

    x=-1010  [x]~反~=1,0101

    **小数**
    $$[x]_{\text{反}}= \begin{cases}
        x\quad 1>x\geq 0 \\
        (2-2^{-n})+x\quad 0\geq x>-1(mod 2-2^{-n})
    \end{cases}
    $$
    x=+0.1110    [x]~反~=0.1110(前面0表示符号位)

    x=-0.1100  [x]~反~=1.0011
#### 移码表示法
补码表示很难直接判断其真值大小

![移码](/compose/75.png)
1. 定义

    $[x]_{\text{移}}=2^{n}+x(2^{n}>x\geq -2^{n})$

    x为真值，n为整数的位数

    x=10100 [x]~移~=2^5^+10100=1,10100(,将符号位和数值部分分开)

    x=-10100 [x]~移~=2^5^-10100=0,01100
2. 补码和移码的比较

![比较](/compose/76.png)

3. 真值、补码和移码的对照表

![对照表](/compose/77.png)
#### 小结
- 最高位为符号位，整数用，隔开。小数用.隔开
- 对于正数，原码=补码=反码
- 对于负数，符号位为1，数值部分

| 补码 | 反码 |
| :-: | :-: |
| 原码数值部分取反加1 | 原码数值部分取反 |

#### 例子
![例1](/compose/73.png)

![例2](/compose/74.png)

## 数的定点表示和浮点表示
**计算机没有专门的硬件表示小数点**

**小数点按约定方式标出**
### 定点表示(正数的补码、反码和原码相同)
| 定点机 | 小数定点机 ![](/compose/78.png =x60) | 整数定点机 ![](/compose/79.png =x60) |
| :-: | :-: | :-: |
|原码|-(1-2^-n^)~+(1-2^-n)|-(2^n^-1)~+(2^n^-1)|
|补码|-1~+(1-2^-n^) (-1是S~f~为1S~1~\~S~n~为0转换为真值时符号位-数值部分取反加1为1所以是-1)|-2^n^~+(2^n^-1) (-2^n^是S~f~为1S~1~\~S~n~为0转换为真值时符号位-数值部分取反加1为(2^n^-1)+1所以是-2^n^)|
|反码|(1-2^-n^)~+(1-2^-n)|-(2^n^-1)~+(2^n^-1)|
### 浮点表示
#### 为什么要引入浮点数表示
- 编程困难，程序员要调节小数点的位置
- 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长
- 数据存储单元利用率低
#### 浮点表示的格式
![](/compose/80.png)

![](/compose/81.png)
#### 浮点表示范围(原码，基值为2)
![](/compose/82.png)
::: info UnderStand
**最大正数**:数符为0, 尾数的数值部分为全1(1-2^-n^) 阶符为0, 阶码的数值部分为全1(2^m^-1) 就是0.11111111...小数点向右移动m位

**最大负数数**:数符位1, 尾数的数值部分位2^-n^ 阶符为1, 阶码的数值部分为全1(2^m^-1) 就是0.0000...001小数点向左移动m位
:::
#### 浮点数的规格化
- r=2 尾数的最高位为1 尾数移1位，阶码+-1
- r=4 尾数的最高2位不全为0 尾数移2位，阶码+-1
- r=8 尾数的最高3位不全为0 尾数移3位，阶码+-1
![例子](/compose/83.png)

#### 举例
![例1](/compose/84.png)

![例2](/compose/85.png)
#### 机器零
- 当浮点数**尾数为0**时，不论其阶码为何值按机器零处理
- 当浮点数**阶码等于或小于它所表示的最小数**时，不论尾数为何值，按机器零处理

### IEEE 754标准
![](/compose/86.png)

## 定点运算
### 移位运算
#### 数学意义
15.m=1500.cm(小数点右移2位但是这种表示在计算机中不适合(计算机没有硬件表示小数点))
|机器用语|15相当于小数点左移2位(小数点不动)|
|:-:|:-:|
|左移|绝对值扩大|
|右移|绝对值缩小|

在计算机中，移位和加减配合，实现乘除法

#### 算术移位规则
![规则](/compose/87.png)
::: info 补码规则理解
假设真值x=-0.x~1~x~2~...x~k~100...000

[x]~补~=1.\~x~1~\~x~2~...\~x~k~100...000

数值后半部分100...000取反加1得100...000前半部分x~1~x~2~...x~k~取反得\~x~1~\~x~2~...\~x~k~

后半部分取反加1(1000取反0111加1是1000和原码相同 加1的意义和取反意义相同)就是取反再取反(双重取反就是没取反)就相当于原码 

前半部分取反相当于反码

补码左移后半部分由于和原码相同补0  

补码右移时前半部分由于和反码相同补1
:::
::: details 例子
![例1](/compose/88.png)

![例2](/compose/89.png)
:::
#### 算术移位的硬件实现
![符号位不变 自循环](/compose/90.png)
#### 算术移位与逻辑移位的区别
![](/compose/91.png)

### 加减法运算
#### 补码加减运算公式
1. 加法

    **整数** [A]~补~+[B]~补~=[A+B]~补~(mod 2^n+1^)

    **小数** [A]~补~+[B]~补~=[A+B]~补~(mod 2)

2. 减法(A-B=A+(-B))

    **整数** [A-B]~补~=[A+(-B)]~补~=[A]~补~+[-B]~补~(mod 2^n+1)

    **小数** [A-B]~补~=[A+(-B)]~补~=[A]~补~+[-B]~补~(mod 2)

3. 举例

![](/compose/92.png)

#### 溢出判断
1. 一位符号位判溢出

    参加操作的**两个数**求补数后的**符号位相同**，其结果的符号与原操作数的符号不同，即为溢出(只有两个正或两个负才有溢出  两个加之后的符号位是1 或者两个减之后的符号位是0 就是溢出)

硬件实现:最高有效位的进位(异或)符号位的进位=1 溢出

2. 两位符号位判溢出 
![](/compose/93.png)
::: info 
01 表示正溢出 正数的补码是本身 溢出会产生进位 导致01

10 表示负溢出 负数的补码是反码加1 如果真值会溢出(导致进位)其补码反而不会溢出(不进位 11+11变成110)如果真值不溢出 其补码反而会溢出(11+11+进位的1是111)
:::
#### 补码加减法的硬件配置
![](/compose/94.png)
::: tip
G~A~是加法标志位 G~S~是减法标志位 负数存进内存时就是补码  当减法标志位为1 将其求补码输入加法器
:::
### 乘法运算
#### 笔算乘法
![过程](/compose/95.png)
**在计算机中要解决的问题**
- [x] 符号位单独处理

    将乘数和被乘数的符号位通过一个异或电路
- [x] 乘数的某一位决定是否加被乘数

    每次判断乘数最后一位 每判断一位 乘数右移一位
- [x] 4个位积一起相加

    1. 将后面的位积左移一位和前面位积相加(溢出不好操作)
    2. 将前面的位积右移一位和后面位积相加(溢出用一个相同大小寄存器接着)
- [x] 乘积的位数扩大一倍

    用一个相同位数的寄存器接着
#### 笔算乘法改进
![过程](/compose/96.png)
![过程](/compose/97.png)
::: tip Review
![运算器结构](/imgs/image-20230310110115389.png)

1. 被乘数放到X里(A)，乘数放到MQ里(B)
2. ACC现在是0.0000，MQ是1011，X是0.1101
3. 乘数末位为1，部分积加上被乘数ACC+X=0.1101
4. 右移一位，ACC(部分积)变成0.0110，溢出的1到乘数(MQ)的高位，MQ变成1,101(由于乘数要右移高位露出来了，如果补0浪费空间，但是部分积的低位是有用的不能因为移位而丢掉，于是放在乘数(MQ)的高位)
5. 乘数末位是1，部分积加上被乘数ACC+X=1.0011
6. 右移一位，ACC(部分积)变成0.1001 MQ(乘数)变成11,10
7. 循环判断乘数直到乘完

**总结**

乘数的末位在判断完后就没用了移位丢掉
，而部分积的末位不应该因为移位丢掉(它是结果)所以我们把它放在乘数的高位
乘数乘一位丢一位我们的部分积要保存一位
:::
#### 原码的乘法
![](/compose/98.png)

![原码一位乘的硬件](/compose/99.png)

- 计数器C统计移位的次数来判断是否结束
- S是符号位
- G~m~是乘法标志位
### 除法运算
#### 笔算除法
1. 分析笔算除法

![](/compose/100.png)
2. 笔算除法和机器除法的比较

![](/compose/101.png)
#### 原码除法
![](/compose/102.png)
![](/compose/103.png)
- 恢复余数法

::: details 解
![](/compose/104.png)
![](/compose/105.png)
:::
![](/compose/107.png)
- 加减交替法
::: details 解
![](/compose/106.png)
:::

## 浮点运算
### 加减运算
x=S~x~*2^jx^ y=S~y~*2^jy^
1. 对阶
    1. 求阶差

        ![](/compose/108.png)

        当j~x~-j~y~<0，j~x~< j~y~，有两种方法让j~x~=j~y~，第一种是让j~x~变小，那么S~x~就要向左移。第二种让j~y~变大，S~y~向右移。若S~x~向左移，由于位数的关系，高位的1可能消失，会影响大小，而若S~y~向右移，低位的1可能会消失，会影响精度，所有一般选择阶码小的放大来对齐阶码
    2. 对阶原则
        **小阶向大阶看齐**
2. 尾数求和

    ![例6.4](/compose/109.png)

3. 规格化

    ![](/compose/110.png)

    ![](/compose/111.png)
4. 舍入

在`对阶`和`右规`过程中，末位如果为1，移位会引起误差，所以我们考虑舍入

- 0舍1入法
- 恒置1法

## 算术逻辑单元
![](/compose/112.png)
### 快速进位链
1. 并行加法器

![](/compose/113.png)

计算S~i~的速度主要取决于计算C~i-1~的速度，因此提高计算进位的速度很重要

2. 串行进位链

![](/compose/114.png)

3. 并行进位链

![](/compose/115.png)

串行进位链**时间长**，并行进位链**电路复杂**，我们可以结合两种方式进行改进
1. 单重分组跳跃进位链

![](/compose/116.png)

2. 双重分组跳跃进位链

![](/compose/117.png)