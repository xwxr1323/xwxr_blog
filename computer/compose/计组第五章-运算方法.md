---
title: 第五章 运算方法
category: 计算机组成原理
order: 5
excerpt: 计组第五章-运算方法
---

## 无符号数和有符号数
### 无符号数
如果它保存在寄存器中 那么它的大小就是寄存器的位数  8位寄存器表示范围是0~255(8个0到8个1) 16位寄存器表示范围是0~65535(8个0到16个1)
### 有符号数

#### 机器数和真值

| 真值 | 机器数 |
| :-: | :-: |
| 带符号的数 | 符号数字化的数 |
| 符号在前 | 取第一位表示符号(1是- 0是+) |
| +101,-101 | 1,101,0,101 |

#### 原码表示法 
1. 定义

    **整数**
    $$[x]_{原}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        2^{n}-x\quad 0\geq x>-2^{n}
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1110  [x]~原~=0,1110

    x=-1110  [x]~原~=2^4^-(-1110)=1,1110

    **小数**
    $$[x]_{原}= \begin{cases}
        x\quad 1>x\geq 0 \\
        1-x\quad 0\geq x>-1
    \end{cases}
    $$
    x=+0.1101    [x]~原~=0.1101(前面0表示符号位)

    x=-0.1101    [x]~原~=1-(-0.1101)=1.1101

2. 特点
    - 简单
    - 直观
3. 缺点

    当需要进行加法运算时

    | 要求  数1 数2 | 实际操作  结果符号 |
    | :-: | :-: |
    | 加法  正  正 | 加 正|
    | 加法  正  负 | 减  可正可负 |
    | 加法  负  正 | 减  可正可负 |   
    | 加法  负  负 | 加  负 | 
    ::: info 
    能否找到一个与负数等价的正数来代替这个负数

    使得减法-->加法
    :::
#### 补码表示法
1. 补的概念
    ::: tip 时钟
    我们要把时间从6点调到3点

    逆时针  直接6-3=3

    顺时针  6+9=15-12=3

    可见-3可以用+9代替 也就是把减法-->加法

    因为时钟以12为模  每经历12小时(每到12点)就会变成0

    我们称+9是-3以12为模的补数  记作-3=+9(mod 12)
    :::
    **结论**
    - 一个负数加上**模**即可得到该负数的补数
    - 一个正数和一个负数互为补数时 它们绝对值之和即为**模**数

    **计算机的补数**
    - 4位寄存器(模16)
        ::: tip UnderStand
        如果想1011-->0000

        逆向    1011-1011=0000

        正向    1011+0101=10000(4位寄存器最高位忽略)=0000

        所以-1011=+0101(mod 2^4^)

        -0.1001=+1.0111(mod 2)
        :::
    - 正数的补数即为其本身
        ![img](/compose/72.png)
    - 对于机器码
    ::: info 对于机器码

    **正数**
    
    +0101 = 0,0101 其补码是本身 
    
    0,0101=0,0101(mod 2^4+1^)

    **负数**
    
    -0101=1,0101 其补码是100000-0101=1,1011  
    
    1,0101=1,1011(mod 2^4+1^)
    :::

2. 补码定义

    **整数**
    $$[x]_{补}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        2^{n+1}+x\quad 0\geq x>-2^{n}(mod 2^{n+1})
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1010  [x]~补~=0,1010

    x=-1011000  [x]~补~=2^7+1^+(-1011000)=1,0101000

    **小数**
    $$[x]_{原}= \begin{cases}
        x\quad 1>x\geq 0 \\
        2+x\quad 0\geq x>-1(mod 2)
    \end{cases}
    $$
    x=+0.1110    [x]~补~=0.1110(前面0表示符号位)

    x=-0.1100  [x]~补~=2+(-0.1100)=1.0100
#### 反码表示法
1. 定义

    **整数**
    $$[x]_{反}= \begin{cases}
        0, x\quad 2^{n}>x\geq 0 \\
        (2^{n+1}-1)+x\quad 0\geq x>-2^{n}(mod 2^{n+1}-1)
    \end{cases}
    $$
    x为真值 n为整数的位数

    x=+1010  [x]~反~=0,1010

    x=-1010  [x]~反~=1,0101

    **小数**
    $$[x]_{反}= \begin{cases}
        x\quad 1>x\geq 0 \\
        (2-2^{-n})+x\quad 0\geq x>-1(mod 2-2^{-n})
    \end{cases}
    $$
    x=+0.1110    [x]~反~=0.1110(前面0表示符号位)

    x=-0.1100  [x]~反~=1.0011
#### 移码表示法
补码表示很难直接判断其真值大小

![移码](/compose/75.png)
1. 定义

    $[x]_{移}=2^{n}+x(2^{n}>x\geq -2^{n})$

    x为真值，n为整数的位数

    x=10100 [x]~移~=2^5^+10100=1,10100(,将符号位和数值部分分开)

    x=-10100 [x]~移~=2^5^-10100=0,01100
2. 补码和移码的比较

![比较](/compose/76.png)

3. 真值、补码和移码的对照表

![对照表](/compose/77.png)
#### 小结
- 最高位为符号位，整数用，隔开。小数用.隔开
- 对于正数，原码=补码=反码
- 对于负数，符号位为1，数值部分

| 补码 | 反码 |
| :-: | :-: |
| 原码数值部分取反加1 | 原码数值部分取反 |

#### 例子
![例1](/compose/73.png)

![例2](/compose/74.png)

## 数的定点表示和浮点表示
**计算机没有专门的硬件表示小数点**

**小数点按约定方式标出**
### 定点表示(正数的补码、反码和原码相同)
| 定点机 | 小数定点机 ![](/compose/78.png =x60) | 整数定点机 ![](/compose/79.png =x60) |
| :-: | :-: | :-: |
|原码|-(1-2^-n^)~+(1-2^-n)|-(2^n^-1)~+(2^n^-1)|
|补码|-1~+(1-2^-n^) (-1是S~f~为1S~1~\~S~n~为0转换为真值时符号位-数值部分取反加1为1所以是-1)|-2^n^~+(2^n^-1) (-2^n^是S~f~为1S~1~\~S~n~为0转换为真值时符号位-数值部分取反加1为(2^n^-1)+1所以是-2^n^)|
|反码|(1-2^-n^)~+(1-2^-n)|-(2^n^-1)~+(2^n^-1)|
### 浮点表示
#### 为什么要引入浮点数表示
- 编程困难，程序员要调节小数点的位置
- 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长
- 数据存储单元利用率低
#### 浮点表示的格式
![](/compose/80.png)

![](/compose/81.png)
#### 浮点表示范围(原码，基值为2)
![](/compose/82.png)
::: info UnderStand
**最大正数**:数符为0, 尾数的数值部分为全1(1-2^-n^) 阶符为0, 阶码的数值部分为全1(2^m^-1) 就是0.11111111...小数点向右移动m位

**最大负数数**:数符位1, 尾数的数值部分位2^-n^ 阶符为1, 阶码的数值部分为全1(2^m^-1) 就是0.0000...001小数点向左移动m位
:::
#### 浮点数的规格化
- r=2 尾数的最高位为1 尾数移1位，阶码+-1
- r=4 尾数的最高2位不全为0 尾数移2位，阶码+-1
- r=8 尾数的最高3位不全为0 尾数移3位，阶码+-1
![例子](/compose/83.png)

#### 举例
![例1](/compose/84.png)

![例2](/compose/85.png)
#### 机器零
- 当浮点数**尾数为0**时，不论其阶码为何值按机器零处理
- 当浮点数**阶码等于或小于它所表示的最小数**时，不论尾数为何值，按机器零处理

### IEEE 754标准
![](/compose/86.png)