---

category: backend

tag: 正则

order: 3

excerpt: 正则

---
# :frog: 正则

如何判断字符串是否是有效的电话号码。

很自然的想到通过程序判断
```java
boolean isValidMobileNumber(String s) {
    // 是否是11位？
    if (s.length() != 11) {
        return false;
    }
    // 每一位都是0~9：
    for (int i=0; i<s.length(); i++) {
        char c = s.charAt(i);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return true;
}
```

但是还需要判断电子邮件，名字，日期等等..

这要写多少代码。一种简单的方法孕育而生-正则表达式

正则表达式可以用一种规则来匹配字符串

正则表达式是一套标准，它可以用于任何语言。Java标准库的`java.util.regex`包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。

如果我们要判断年份是不是20##年
，用程序是这样写的
```java
boolean isTwo(String s){
    if(("20").equals(s.charAt(0)+s.charAt(1))){
            return false;
    }
    return true;
}
```

若用正则则是`20\d\d`
```java
String regex = "20\\d\\d";
    System.out.println("2019".matches(regex)); //false
```
java中`\`是转义字符，表示`\`就得用`\\`

使用正则表达式，不必编写复杂的代码来判断，只需要编写一个简单的正则规则即可。
## 匹配规则

|正则表达式|规则|可以匹配|
|:-:|:-:|:-:|
|`A`|	指定字符|	`A`|
|`\u548c`|	指定Unicode字符|	`和`|
|`.`|	任意字符|	`a`，`b`，`&`，`0`|
|`\d`|	数字0~9|	`0`~`9`|
|`\w`|大小写字母，数字和下划线|`a`~ `z`，`A`~ `Z`，`0`~`9`，`_`|
|`\s`|	空格、Tab键|	`空格`，`Tab`|
|`\D`|	非数字|	`a`，`A`，`&`，`_`，`……`|
|`\W`|	非\w|	`&`，`@`，`中`，`……`|
|`\S`|	非\s|	`a`，`A`，`&`，`_`，`……`|

多个字符的匹配规则

|正则表达式|规则|可以匹配|
|:-:|:-:|:-:|
|`A*`|任意个数字符|`空`，`A`，`AA`，`AAA`，`……`|
|`A+`|至少1个字符|`A`，`AA`，`AAA`，`……`|
|`A?`|0个或1个字符|`空`，`A`|
|`A{3}`|指定个数字符|`AAA`|
|`A{2,3}`|指定范围个数字符|`AA`，`AAA`|
|`A{2,}`|至少n个字符|`AA`，`AAA`，`AAAA`，`……`|
|`A{0,3}`|最多n个字符|`空`，`A`，`AA`，`AAA`|

复杂匹配

|正则表达式|规则|可以匹配|
|:-:|:-:|:-:|
|`^`|开头|字符串开头|
|`$`|结尾|字符串结束|
|`[ABC]`|`[…]`内任意字符|`A`，`B`，`C`|
|`[A-F0-9xy]`|指定范围的字符|`A，……，F`，`0，……，9`，`x`，`y`|
|`[^A-F]`|指定范围外的任意字符|`非A~F`|
|`AB\|CD\|EF`|`AB`或`CD`或`EF`|`AB`,`CD`,`EF`|

现在我们想要匹配字符串`learn java`、`learn php`和`learn go怎`么办？一个最简单的规则是`learn\sjava|learn\sphp|learn\sgo`，但是这个规则太复杂了，可以把公共部分提出来，然后用`(...)`把子规则括起来表示成`learn\\s(java|php|go)`

## 分组匹配

我们使用`"java".matches(re)`可以很轻易的判定一个字符串是不是指定规则的，但是我们不能提取出来我们想要的字符串，java的`java.util.regex`提供了一个`Pattern`对象供我们进行匹配，匹配成功后返回一个`Matcher`对象，这个对象包含匹配到的字串

第一步，调用`Pattern.compile("re表达式")`创建一个Pattern对象。

第二步，调用` pattern.matcher("内容")`返回一个`Matcher`对象。

第三步，调用`matcher.matches()`方法判断有没有匹配成功，匹配成功会返回`true`

第四步，调用` matcher.group(0);`返回匹配到的整个字符串

若想分组匹配，则需使用括号。下面是分组匹配的一个例子
```java
Pattern p = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
Matcher m = p.matcher("010-12345678");
if (m.matches()) {
    String g1 = m.group(1);
    String g2 = m.group(2);
    System.out.println(g1);
    System.out.println(g2);
} else {
    System.out.println("匹配失败!");
}
```
匹配到的整个字符串在`group(0)`中，匹配到第一个括号的在`group(1)`，匹配到第二个括号的在`group(2)`

## 非贪婪匹配

有这样的场景，给定一个字符串表示的数字，判断该数字末位有几个0。例如`1110000`，很简单可以写出正则表达式`(\d+)(0*)`

我们使用分组匹配来获取
```java
Pattern p = Pattern.compile("(\\d+)(0*)");
Matcher m = p.matcher("1110000")
if(m.matches()){
    matcher.group(1);//"1110000"
    matcher.group(2);//""
}
```

然而第二个字串是空，这是因为正则默认是贪婪匹配，`\d+` `+`匹配的是1个或更多，至少匹配一个，由于默认是贪婪匹配而且`\d`也可以匹配`0`，于是`\d+`会尽可能多地向后匹配，所以把后面的`0`也包含了进来

我们要让`\d+`尽可能少匹配,让他变成`非贪婪匹配`。也很简单，就是在匹配的规则后面加个`?`就行，`?`表示匹配`0`或`1`，加在`*`或`+`后面表示非贪婪匹配，尽可能少的匹配。

`\d??`对于`\d?`来说，可以匹配1个，也可以匹配0个，但是因为后面的`?`表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个。